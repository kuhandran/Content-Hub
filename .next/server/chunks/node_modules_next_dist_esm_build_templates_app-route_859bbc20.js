module.exports=[48828,e=>{"use strict";var t=e.i(47909),a=e.i(74017),n=e.i(96250),s=e.i(59756),i=e.i(61916),l=e.i(74677),r=e.i(69741),o=e.i(16795),c=e.i(87718),h=e.i(95169),d=e.i(47587),f=e.i(66012),p=e.i(70101),u=e.i(26937),_=e.i(10372),E=e.i(93695);e.i(52474);var m=e.i(220);let y=e.r(22734),C=e.r(14747),D=e.r(54799),{NextResponse:S}=e.r(89171),{getSupabase:g}=e.r(14348),{mapFileToTable:w,getFileExtension:T,ALLOWED_EXTENSIONS:v,IGNORED_DIRS:R,getPublicDir:N}=e.r(77953),O=e.r(8627);function U(){let e=N(),t=new Map;return!function a(n){if(y.existsSync(n))for(let s of y.readdirSync(n,{withFileTypes:!0})){let i=C.join(n,s.name),l=C.relative(e,i);if(s.isDirectory())R.includes(s.name)||a(i);else if(v.includes(C.extname(i).toLowerCase()))try{let e=y.readFileSync(i,"utf-8"),a=D.createHash("sha256").update(e).digest("hex"),{table:n,fileType:s}=w(i);"unknown"!==n&&t.set(l,{hash:a,content:e,table:n,fileType:s})}catch(e){}}}(e),t}async function b(e){let t=U(),a=[],n=0,s=0,i=0;try{let l=[],r=await e.from("sync_manifest").select("*");if(r.error){let e=r.error.message||"Unknown Supabase error";if(e.includes("does not exist")||e.includes("relation")&&e.includes("does not exist"))l=[];else throw Error(`Failed to fetch sync_manifest: ${e}`)}else l=r.data||[];let o=new Map(l?.map(e=>[e.file_path,e])||[]);for(let[e,i]of t){let t=o.get(e);t?t.file_hash!==i.hash&&(a.push({path:C.join("public",e),relativePath:e,status:"modified",table:i.table,hash:i.hash,fileType:i.fileType}),s++):(a.push({path:C.join("public",e),relativePath:e,status:"new",table:i.table,hash:i.hash,fileType:i.fileType}),n++)}for(let[e,n]of o)!t.has(e)&&(a.push({path:C.join("public",e),relativePath:e,status:"deleted",table:n.table_name,hash:n.file_hash,fileType:T(e)}),i++);return{changes:a,stats:{files_scanned:t.size,new_files:n,modified_files:s,deleted_files:i}}}catch(e){throw Error(`Scan failed: ${e.message}`)}}async function L(e){let t=U(),a=[],n=0,s=0,i=0;try{let l=await e`SELECT file_path, file_hash, table_name FROM sync_manifest`,r=new Map((l||[]).map(e=>[e.file_path,e]));for(let[e,i]of t){let t=r.get(e);t?t.file_hash!==i.hash&&(a.push({path:C.join("public",e),relativePath:e,status:"modified",table:i.table,hash:i.hash,fileType:i.fileType}),s++):(a.push({path:C.join("public",e),relativePath:e,status:"new",table:i.table,hash:i.hash,fileType:i.fileType}),n++)}for(let[e,n]of r)!t.has(e)&&(a.push({path:C.join("public",e),relativePath:e,status:"deleted",table:n.table_name,hash:n.file_hash,fileType:T(e)}),i++);return{changes:a,stats:{files_scanned:t.size,new_files:n,modified_files:s,deleted_files:i}}}catch(e){throw Error(`Scan failed (pg): ${e.message}`)}}async function $(e,t){let a=0,n=N();for(let s of t)try{let t=C.join(n,s.relativePath);if("deleted"===s.status){let{error:t}=await e.from(s.table).delete().match({file_path:s.relativePath});!t&&a++}else if("new"===s.status||"modified"===s.status){let n=y.readFileSync(t,"utf-8"),i=new Date().toISOString(),l=C.basename(t,C.extname(t)),r={};if("collections"===s.table){let e=s.relativePath.split(C.sep),t=e.findIndex(e=>"collections"===e),a=e[t+1],o=e[t+2];try{let e=JSON.parse(n);r={lang:a,type:o,filename:l,file_content:e,file_hash:s.hash,synced_at:i}}catch{continue}}else if(["config_files","data_files"].includes(s.table))try{let e=JSON.parse(n);r={filename:l,file_type:s.fileType,file_content:e,file_hash:s.hash,synced_at:i}}catch{continue}else r="static_files"===s.table?{filename:l,file_type:s.fileType,file_content:n,file_hash:s.hash,synced_at:i}:{filename:l,file_path:s.relativePath,file_type:s.fileType,file_hash:s.hash,synced_at:i};let{error:o}=await e.from(s.table).upsert(r,{onConflict:"filename"});o||(a++,await e.from("sync_manifest").upsert({file_path:s.relativePath,file_hash:s.hash,table_name:s.table,last_synced:i},{onConflict:"file_path"}))}}catch(e){console.error(`Failed to apply change ${s.relativePath}: ${e.message}`)}return{status:"completed",applied:a}}async function P(e,t){let a=0,n=N();for(let s of t)try{let t=C.join(n,s.relativePath),i=new Date().toISOString(),l=C.basename(t,C.extname(t));if("deleted"===s.status)await e.unsafe(`DELETE FROM ${s.table} WHERE file_path = ${e.parameters([s.relativePath])}`),a++;else if("new"===s.status||"modified"===s.status){let n=y.readFileSync(t,"utf-8");switch(s.table){case"collections":{let t=s.relativePath.split(C.sep),a=t.findIndex(e=>"collections"===e),r=t[a+1],o=t[a+2],c=JSON.parse(n);await e`
              INSERT INTO collections (lang, type, filename, file_content, file_hash, synced_at)
              VALUES (${r}, ${o}, ${l}, ${e.json(c)}, ${s.hash}, ${i})
              ON CONFLICT (lang, type, filename) DO UPDATE SET file_content = EXCLUDED.file_content, file_hash = EXCLUDED.file_hash, synced_at = EXCLUDED.synced_at
            `;break}case"config_files":{let t=JSON.parse(n);await e`
              INSERT INTO config_files (filename, file_type, file_content, file_hash, synced_at)
              VALUES (${l}, ${s.fileType}, ${e.json(t)}, ${s.hash}, ${i})
              ON CONFLICT (filename) DO UPDATE SET file_type = EXCLUDED.file_type, file_content = EXCLUDED.file_content, file_hash = EXCLUDED.file_hash, synced_at = EXCLUDED.synced_at
            `;break}case"data_files":{let t=JSON.parse(n);await e`
              INSERT INTO data_files (filename, file_type, file_content, file_hash, synced_at)
              VALUES (${l}, ${s.fileType}, ${e.json(t)}, ${s.hash}, ${i})
              ON CONFLICT (filename) DO UPDATE SET file_type = EXCLUDED.file_type, file_content = EXCLUDED.file_content, file_hash = EXCLUDED.file_hash, synced_at = EXCLUDED.synced_at
            `;break}case"static_files":await e`
              INSERT INTO static_files (filename, file_type, file_content, file_hash, synced_at)
              VALUES (${l}, ${s.fileType}, ${n}, ${s.hash}, ${i})
              ON CONFLICT (filename) DO UPDATE SET file_type = EXCLUDED.file_type, file_content = EXCLUDED.file_content, file_hash = EXCLUDED.file_hash, synced_at = EXCLUDED.synced_at
            `;break;case"images":await e`
              INSERT INTO images (filename, file_path, mime_type, file_hash, synced_at)
              VALUES (${l}, ${s.relativePath}, ${`image/${T(t)}`}, ${s.hash}, ${i})
              ON CONFLICT (filename) DO UPDATE SET file_path = EXCLUDED.file_path, mime_type = EXCLUDED.mime_type, file_hash = EXCLUDED.file_hash, synced_at = EXCLUDED.synced_at
            `;break;case"resumes":await e`
              INSERT INTO resumes (filename, file_type, file_path, file_hash, synced_at)
              VALUES (${l}, ${T(t)}, ${s.relativePath}, ${s.hash}, ${i})
              ON CONFLICT (filename) DO UPDATE SET file_type = EXCLUDED.file_type, file_path = EXCLUDED.file_path, file_hash = EXCLUDED.file_hash, synced_at = EXCLUDED.synced_at
            `;break;case"javascript_files":await e`
              INSERT INTO javascript_files (filename, file_path, file_content, file_hash, synced_at)
              VALUES (${l}, ${s.relativePath}, ${n}, ${s.hash}, ${i})
              ON CONFLICT (filename) DO UPDATE SET file_path = EXCLUDED.file_path, file_content = EXCLUDED.file_content, file_hash = EXCLUDED.file_hash, synced_at = EXCLUDED.synced_at
            `}await e`
          INSERT INTO sync_manifest (file_path, file_hash, table_name, last_synced)
          VALUES (${s.relativePath}, ${s.hash}, ${s.table}, ${i})
          ON CONFLICT (file_path) DO UPDATE SET file_hash = EXCLUDED.file_hash, table_name = EXCLUDED.table_name, last_synced = EXCLUDED.last_synced
        `,a++}}catch(e){console.error(`[SYNC][PG] Failed to apply ${s.relativePath}:`,e.message)}return{status:"completed",applied:a}}async function I(e){try{let t,a=(await e.json()).mode||"scan",n=e.headers?.get?.("x-vercel-id"),s=e.headers?.get?.("x-forwarded-for"),i=process.env.VERCEL_REGION||"unknown-region",l=process.env.VERCEL_ENV||"production";console.log("[SYNC] Request received",{mode:a,vercelId:n,forwardedFor:s,region:i,env:l,time:new Date().toISOString()});let r=!!O;console.log("[SYNC] Client selection",{useSql:r}),r||(t=g(),console.log("[SYNC] Supabase client initialized",{supabaseUrlConfigured:!!process.env.SUPABASE_URL,serviceKeyConfigured:!!process.env.SUPABASE_SERVICE_ROLE_KEY}));let o=new Date().toISOString();if("scan"===a){console.log("[SYNC] Scan starting");let{changes:e,stats:a}=r?await L(O):await b(t);return console.log("[SYNC] Scan completed",{stats:a,changesCount:e.length}),S.json({status:"success",mode:"scan",...a,changes:e.slice(0,100),timestamp:o})}if("pull"===a){console.log("[SYNC] Pull starting");let{changes:e,stats:a}=r?await L(O):await b(t),n=r?await P(O,e):await $(t,e);return console.log("[SYNC] Pull completed",{stats:a,applied:n.applied,changesCount:e.length}),S.json({status:"success",mode:"pull",...a,changes:e.slice(0,50),timestamp:o})}if("push"===a)return console.warn("[SYNC] Push requested but not implemented"),S.json({status:"error",mode:"push",error:"Push mode is not yet implemented",timestamp:o},{status:501});else return console.warn("[SYNC] Unknown mode",{mode:a}),S.json({status:"error",mode:a,error:`Unknown mode: ${a}. Use 'scan', 'pull', or 'push'`,timestamp:o},{status:400})}catch(e){return console.error("[SYNC] Error handler",{message:e.message,stack:e.stack}),S.json({status:"error",mode:"unknown",error:e.message||"Internal server error",timestamp:new Date().toISOString()},{status:500})}}async function A(e){return console.log("[SYNC] GET status",{vercelId:e.headers?.get?.("x-vercel-id"),region:process.env.VERCEL_REGION||"unknown-region",time:new Date().toISOString()}),S.json({status:"success",message:"Sync endpoint is active",available_modes:["scan","pull","push"],usage:'POST /api/admin/sync with { mode: "scan" | "pull" | "push" }',timestamp:new Date().toISOString()})}e.s(["GET",()=>A,"POST",()=>I],49728);var x=e.i(49728);let X=new t.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/admin/sync/route",pathname:"/api/admin/sync",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/app/api/admin/sync/route.js",nextConfigOutput:"",userland:x}),{workAsyncStorage:j,workUnitAsyncStorage:k,serverHooks:F}=X;function H(){return(0,n.patchFetch)({workAsyncStorage:j,workUnitAsyncStorage:k})}async function M(e,t,n){X.isDev&&(0,s.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let y="/api/admin/sync/route";y=y.replace(/\/index$/,"")||"/";let C=await X.prepare(e,t,{srcPage:y,multiZoneDraftMode:!1});if(!C)return t.statusCode=400,t.end("Bad Request"),null==n.waitUntil||n.waitUntil.call(n,Promise.resolve()),null;let{buildId:D,params:S,nextConfig:g,parsedUrl:w,isDraftMode:T,prerenderManifest:v,routerServerContext:R,isOnDemandRevalidate:N,revalidateOnlyGenerated:O,resolvedPathname:U,clientReferenceManifest:b,serverActionsManifest:L}=C,$=(0,r.normalizeAppPath)(y),P=!!(v.dynamicRoutes[$]||v.routes[U]),I=async()=>((null==R?void 0:R.render404)?await R.render404(e,t,w,!1):t.end("This page could not be found"),null);if(P&&!T){let e=!!v.routes[U],t=v.dynamicRoutes[$];if(t&&!1===t.fallback&&!e){if(g.experimental.adapterPath)return await I();throw new E.NoFallbackError}}let A=null;!P||X.isDev||T||(A="/index"===(A=U)?"/":A);let x=!0===X.isDev||!P,j=P&&!x;L&&b&&(0,l.setManifestsSingleton)({page:y,clientReferenceManifest:b,serverActionsManifest:L});let k=e.method||"GET",F=(0,i.getTracer)(),H=F.getActiveScopeSpan(),M={params:S,prerenderManifest:v,renderOpts:{experimental:{authInterrupts:!!g.experimental.authInterrupts},cacheComponents:!!g.cacheComponents,supportsDynamicResponse:x,incrementalCache:(0,s.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:g.cacheLife,waitUntil:n.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,a,n,s)=>X.onRequestError(e,t,n,s,R)},sharedContext:{buildId:D}},q=new o.NodeNextRequest(e),V=new o.NodeNextResponse(t),Y=c.NextRequestAdapter.fromNodeNextRequest(q,(0,c.signalFromNodeResponse)(t));try{let l=async e=>X.handle(Y,M).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let a=F.getRootSpanAttributes();if(!a)return;if(a.get("next.span_type")!==h.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${a.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let n=a.get("next.route");if(n){let t=`${k} ${n}`;e.setAttributes({"next.route":n,"http.route":n,"next.span_name":t}),e.updateName(t)}else e.updateName(`${k} ${y}`)}),r=!!(0,s.getRequestMeta)(e,"minimalMode"),o=async s=>{var i,o;let c=async({previousCacheEntry:a})=>{try{if(!r&&N&&O&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let i=await l(s);e.fetchMetrics=M.renderOpts.fetchMetrics;let o=M.renderOpts.pendingWaitUntil;o&&n.waitUntil&&(n.waitUntil(o),o=void 0);let c=M.renderOpts.collectedTags;if(!P)return await (0,f.sendResponse)(q,V,i,M.renderOpts.pendingWaitUntil),null;{let e=await i.blob(),t=(0,p.toNodeOutgoingHttpHeaders)(i.headers);c&&(t[_.NEXT_CACHE_TAGS_HEADER]=c),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let a=void 0!==M.renderOpts.collectedRevalidate&&!(M.renderOpts.collectedRevalidate>=_.INFINITE_CACHE)&&M.renderOpts.collectedRevalidate,n=void 0===M.renderOpts.collectedExpire||M.renderOpts.collectedExpire>=_.INFINITE_CACHE?void 0:M.renderOpts.collectedExpire;return{value:{kind:m.CachedRouteKind.APP_ROUTE,status:i.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:a,expire:n}}}}catch(t){throw(null==a?void 0:a.isStale)&&await X.onRequestError(e,t,{routerKind:"App Router",routePath:y,routeType:"route",revalidateReason:(0,d.getRevalidateReason)({isStaticGeneration:j,isOnDemandRevalidate:N})},!1,R),t}},h=await X.handleResponse({req:e,nextConfig:g,cacheKey:A,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:v,isRoutePPREnabled:!1,isOnDemandRevalidate:N,revalidateOnlyGenerated:O,responseGenerator:c,waitUntil:n.waitUntil,isMinimalMode:r});if(!P)return null;if((null==h||null==(i=h.value)?void 0:i.kind)!==m.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==h||null==(o=h.value)?void 0:o.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});r||t.setHeader("x-nextjs-cache",N?"REVALIDATED":h.isMiss?"MISS":h.isStale?"STALE":"HIT"),T&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let E=(0,p.fromNodeOutgoingHttpHeaders)(h.value.headers);return r&&P||E.delete(_.NEXT_CACHE_TAGS_HEADER),!h.cacheControl||t.getHeader("Cache-Control")||E.get("Cache-Control")||E.set("Cache-Control",(0,u.getCacheControlHeader)(h.cacheControl)),await (0,f.sendResponse)(q,V,new Response(h.value.body,{headers:E,status:h.value.status||200})),null};H?await o(H):await F.withPropagatedContext(e.headers,()=>F.trace(h.BaseServerSpan.handleRequest,{spanName:`${k} ${y}`,kind:i.SpanKind.SERVER,attributes:{"http.method":k,"http.target":e.url}},o))}catch(t){if(t instanceof E.NoFallbackError||await X.onRequestError(e,t,{routerKind:"App Router",routePath:$,routeType:"route",revalidateReason:(0,d.getRevalidateReason)({isStaticGeneration:j,isOnDemandRevalidate:N})},!1,R),P)throw t;return await (0,f.sendResponse)(q,V,new Response(null,{status:500})),null}}e.s(["handler",()=>M,"patchFetch",()=>H,"routeModule",()=>X,"serverHooks",()=>F,"workAsyncStorage",()=>j,"workUnitAsyncStorage",()=>k],48828)}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_859bbc20.js.map